// scripts/generate-vfs.ts

import * as fs from 'fs';
import * as path from 'path';

const fontsDir = path.join(__dirname, '../src/assets/fonts');
const outputDir = path.join(__dirname, '../src/fonts');
const outputFile = path.join(outputDir, 'vfs_fonts.ts');

if (!fs.existsSync(outputDir)) {
  fs.mkdirSync(outputDir, { recursive: true });
}

const fonts = fs.readdirSync(fontsDir);

let vfsContent = '// This file is auto-generated by scripts/generate-vfs.ts\n';
vfsContent += 'const vfs = {\n';

fonts.forEach((file, index) => {
  if (file.endsWith('.ttf')) {
    const filePath = path.join(fontsDir, file);
    const base64 = fs.readFileSync(filePath).toString('base64');
    
    // Chunk the base64 string to avoid parser limits
    const chunkSize = 8192; // 8KB chunks
    const chunks: string[] = [];
    for (let i = 0; i < base64.length; i += chunkSize) {
        chunks.push(base64.substring(i, i + chunkSize));
    }
    
    // Create an array of string literals and join them at runtime
    const fontData = `[\n'${chunks.join("',\n'")}'\n].join('')`;

    vfsContent += `  "${file}": ${fontData}`;
    if (index < fonts.length - 1) {
      vfsContent += ',\n';
    }
  }
});

vfsContent += '\n};\n\n';
vfsContent += 'export default vfs;\n';

fs.writeFileSync(outputFile, vfsContent);

console.log('vfs_fonts.ts has been generated successfully.');
